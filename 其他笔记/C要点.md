### C值得注意的地方(想到哪写到哪)

- `#`开头的语句是编译预处理语句(并不是C语句), 在编译源程序之前, 会先进行宏展开, 宏替换.
- `sizeof`计算类型大小是在编译时执行的.
- `printf`不区分双精度, 单精度, 打印时都最多只显示小数点后6位.
- 不同数据类型进行运算, 结果的类型是取值范围较大的那个类型. 同一类型, 有符号转无符号. 过程: 先把操作数类型转换为取值范围较大的操作数的类型, 再进行运算.
- 结构体字节对齐, 是根据成员的最大类型来的(只看基本类型, 数组和结构体类型不看, ), 即步长等于其成员的最大类型的大小. 并且成员的顺序会影响结构体类型大小, 如:

```c
// 大小16
struct One {
    char sex;
    int id; // 1+4<8, 取8
    double value; // 8
};

// 大小24
struct Two {
    char sex; // 1<8, 取8
    double value; // 8
    int id; // 4<8, 取8
};

// 注意结构体类型并不作为步长, 只有基本类型才能作为步长
// 并且结构体中嵌套结构体, 内外类型大小并不合并
// 大小32
struct Student {
    char sex; // 1<8, 取8
    struct Birthday {
        int month; // 4<8, 取8
        double year; // 8
        int day; // 4<8, 取8
    } birthday;
};
```

- 设`a`, `b`均为1, 执行`(m=a>b)&&(n=a>b)`后, `m`值为0, `n`值为1, 原因是短路运算. 与此对应的是`||`. 总结: `A&&B`, 前为假, 后不执行. `A||B`, 前为真, 后不执行.
- 除法与模运算(只能用于整数)例子:

```c
// 除法. 不要多想, 负号提出, 正常除就行
3 / -5 = 0;
-3 / 5 = 0;
-6 / 5 = -1;
6 / -5 = -1;

// 模. 原理 `a - a / b * b`
// 注意C中模规则和Python中不同, Python没用上述规则
// 导致某些模结果不同
3 % -5 = 3;
5 % -3 = 2;
-5 % 3 = -2;
```

- `double n = 20 / 3`, 结果是`6.0`, 而并不是`6.666...` . 看到两个整型相除, 要尤其注意, 看看运算需要的是整型, 还是浮点型, 从而做相应的类型强转.
- 常量指针:

```c
const int *p1 = &a; // 指向地址的内容不可修改
int *const p2 = &b; // 指向的地址不可修改
/* 关键看const在 * 前, 还是后 */
```

- 取反操作: `!n`, `n`是非零数(可以是负数, 浮点), 结果为`0`. `!0`, 结果为`1`. 注意取反后类型都是int型.
- `'\xff'`, 十六进制; `'\012'`, 八进制.
- 编译器会用一个空格字符代替一条注释.